Audit Bug & Error Portal UGC Business Command
1.	Penolakan Biaya Operasional (Operational Cost Reject). Endpoint POST /api/ticketing/operational-costs/[id]/reject sering gagal karena validasi status dan penanganan error yang tidak konsisten. Misalnya, sistem mengharuskan status hardcoded 'sent' yang tidak sesuai enum (quote_status DB tidak memiliki 'sent' saja), sehingga terjadi INVALID_STATUS_TRANSITION. Sebelumnya juga tidak meneruskan actor_user_id dan correlation_id ke RPC, serta mengembalikan kode HTTP salah (400 bukan 422/409)[1][2]. Contoh pesan error yang muncul: “Operational cost cannot be rejected in current status: X. Must be in 'SENT' status.”.
2.	Tipe Alasan Penolakan Hardcoded (Hardcoded Rejection Reasons). Beberapa endpoint masih menggunakan nilai string bukan konstanta SSOT. Misalnya reason_type untuk penolakan biaya operasional atau kuotasi dituliskan langsung, bukan menggunakan daftar OPERATIONAL_COST_REJECTION_REASON_LIST. Ini menyebabkan inkonsistensi antara UI dan DB[3][2]. Error contohnya: “Invalid reason type: xyz. Valid values are: …” (saat validasi frontend).
3.	Enum Status Tidak Sinkron (Waiting_vendor & On_hold). Schema ticket_status atau quote_status dalam DB tidak mengandung nilai seperti waiting_vendor atau on_hold yang disebut di dokumen alur (PDF). Artinya, jika backend atau UI mengacu ke status-status ini, maka akan terjadi error validasi enum. Sebagai contoh, transaksi pipeline/OPR mungkin berasumsi status on_hold namun enum Postgres menolak nilai tersebut[3].
4.	“Assign to Sales” Tanpa Input Potential Revenue. Workflow Lead ke Sales Pool mengharuskan memasukkan potential_revenue. Berdasarkan schema, tabel leads memiliki kolom potential_revenue[4] dan RPC rpc_lead_handover_to_sales_pool menerima p_potential_revenue[5]. Namun di UI tidak ada dialog inputnya, sehingga nilai ini kosong (atau tidak diverifikasi >0) saat memindahkan Lead ke Sales. Akibatnya kondisi “potential_revenue > 0” tidak dipenuhi dan log audit bisa hilang, juga status final Lead (harus terminal) tidak tercapai.
5.	Otomatisasi Perubahan Stage Pipeline. Tabel pipeline_updates ada untuk mencatat setiap perubahan tahap Opportunity[6], tetapi belum ada mekanisme otomatisasi lengkap. Schema hanya menyediakan trigger untuk ID (generate_pipeline_update_id)[7], tanpa fungsi yang memasukkan baris saat Stage berubah. Seharusnya fungsi trigger log_stage_change() (yang terdaftar pada opportunities AFTER UPDATE[8]) membuat entri ke pipeline_updates. Jika trigger ini tidak memanggilnya, maka riwayat stage tidak terlog, sehingga pipeline board dan audit tidak akurat.
6.	Tracking Tiket (Activities, Komentar, SLA). Terdapat beberapa mekanisme tracking: misalnya ticket_comments memicu auto_record_response_on_comment() untuk mencatat respon di tabel ticket_responses[9][10]. Jika trigger ini gagal (mis. hak akses DB), maka komentar tidak tercatat sebagai respon. Selain itu, tabel ticket_sla_tracking mencatat waktu tanggapan pertama dan penyelesaian[11], tapi belum ada trigger untuk membuat baris baru saat tiket dibuat atau memperbarui saat ada tanggapan/penyelesaian. Akibatnya SLA tidak terhitung. Contoh error: SLA tidak terpenuhi tanpa alasan yang jelas, atau audit ticket_events tanpa correlation_id (hanya operator tahu kesalahan)[12].
7.	Kesalahan Status HTTP dan Struktur Error. Banyak endpoint belum konsisten. Contoh pada bug operasional cost di atas, endpoint awal memberikan status 400 alih-alih 422 atau 409[13]. Pesan error kurang terstruktur (tidak ada error_code atau field_errors) yang menyulitkan frontend menampilkan pesan spesifik.
8.	Entitas Tidak Terpakai (Unused Entities). Beberapa tabel/enum tampak tidak digunakan di logika sistem: misalnya tabel cadences (cadences, cadence_steps, cadence_enrollments) yang berkaitan mekanisme nurture flow, serta mungkin tabel sales_plans. Pastikan tidak ada code frontend/API yang merujuk ke entitas-entitas ini sebelum menghapus.
Analisis Penyebab
•	Operasional Cost Reject Endpoint: Kode lama menggunakan string literal status 'sent' yang bukan nilai resmi enum quote_status (lihat definisi enum: quote_status mencakup {draft,sent,accepted,rejected,...}[14], sedangkan RPC sebelumnya mungkin menggunakan hanya 'sent'). Hal ini menyebabkan kegagalan validasi status (MISMATCH). Selain itu, RPC rpc_reject_operational_cost_with_reason awalnya tidak menerima parameter p_actor_user_id atau p_correlation_id, sehingga audit trail (tabel ticket_events) tidak lengkap. Error handling juga tidak standar: larik error_code tidak diisi, dan status HTTP default 400. Laporan audit internal mencatat masalah-masalah ini[1].
•	Hardcoded Reason Types: Frontend mengirimkan reason_type berdasarkan pilihan user. Jika daftar SSOT (OPERATIONAL_COST_REJECTION_REASON_LIST) tidak digunakan, bisa timbul mismatch bila backend menolak tipe yang valid secara domain tapi tidak hardcoded di kode. Ini karena DB tidak enforce nilai ini (tabel operational_cost_rejection_reasons.reason_type bertipe text)[15], validasinya murni di kode.
•	Enum Mismatch (waiting_vendor/on_hold): Dokumen alur menyebut status waiting_vendor dan on_hold di flow lead/tiket. Namun data_schema (lihat kolom ticketing_sla_config.ticket_type, tickets.status, dll.) tidak punya enum tersebut[14]. Kemungkinan besar bug terjadi saat backend mencoba mentransisikan tiket atau leads ke status tersebut, maka Postgres akan error invalid input value for enum.
•	Assign to Sales: Schema leads menunjukkan adanya kolom potential_revenue[16], dan RPC rpc_lead_handover_to_sales_pool mendefinisikan parameter p_potential_revenue[5]. Namun frontend (CRM UI) belum menyediakan input dialog tersebut. Akibatnya nilai potential_revenue tetap null, melanggar aturan bisnis (harus >0) dan membuat Lead tidak bisa lanjut ke Sales Inbox sesuai skenario QA[17]. Selain itu, status terakhir Lead (“Assign to Sales” adalah status terminal) tidak tercatat dengan benar di audit trail jika missing parameter.
•	Pipeline Stage Automation: Tabel pipeline_updates siap menyimpan riwayat (kolom old_stage, new_stage, dsb. di schema[6]). Ada fungsi trigger log_stage_change() terdaftar pada opportunities AFTER UPDATE[8], tetapi implementasi fungsi tersebut belum ada di schema (tidak ditemukan di data_scheme) atau tidak memasukkan ke pipeline_updates. Akibatnya perpindahan stage Opportunity tidak tercatat di pipeline_updates ataupun activities, padahal tabel activities memiliki kolom cadence_enrollment_id, cadence_step_number dll[18] untuk melacak kegiatan pipeline. Ketidakhadiran fungsi log_stage menyebabkan data pipeline tidak sinkron antar tabel.
•	Tracking Tiket dan SLA: Tabel ticket_responses dan ticket_sla_tracking sudah ada[10][11]. Namun, jika trigger auto-record response (pada ticket_comments[19]) gagal dipasang atau fungsi record_ticket_response error, maka komentar tidak tercatat sebagai respons. Begitu pula, tidak ada trigger yang secara otomatis membuat entry ticket_sla_tracking saat tiket baru dibuat atau saat ada respons pertama; padahal tabel ticketing_sla_config ada menetapkan target jam layanan. Kekosongan fungsi ini menyebabkan SLA tampak tidak terpenuhi tanpa waktu tanggapan tercatat.
•	HTTP Codes & Error Structure: Bug audit menunjukkan banyak endpoint belum konsisten mengikuti pedoman (422 untuk validasi, 409 untuk konflik)[13]. Misalnya kasus status tidak sesuai: harusnya 409 Conflict, bukan 400. Format respons lama kadang hanya error string, tanpa error_code yang memudahkan frontend.
•	Entitas Tidak Digunakan: Tabel cadences (untuk workflow otomatis) serta sales_plans tampak tidak dipakai di fitur yang ada. Misalnya, fungsi generate_sales_plan_id ada (schema[20]) tapi tidak ada UI/endpoint untuk membuat Sales Plan. Sama dengan cadence, tidak ada endpoint/flow terkait dalam docs. Oleh karena itu, entitas-entitas ini dapat dipertimbangkan dihapus dengan aman setelah dicek dependencies (tidak merusak trigger/constraint lain).
Solusi & Panduan Implementasi
•	Perbaikan Endpoint Operasional Cost Reject:
•	Gunakan konstanta SSOT: Ganti literal status 'sent' dengan QUOTE_STATUS.SENT (dari src/lib/constants)[2].
•	Buat correlation_id dan actor_user_id: Generate correlation_id = randomUUID() di awal request. Tambahkan parameter p_actor_user_id dan p_correlation_id saat memanggil RPC[21]. Dalam migration SQL (mis. 080_fix_operational_cost_reject_rpc.sql), ubah signature rpc_reject_operational_cost_with_reason untuk menerima kedua parameter baru, lalu perbarui fungsi agar menulis ke ticket_events menggunakan nilai-nilai tersebut[22].
•	Terapkan Validasi Alasan Penolakan: Di frontend dan backend, gunakan array OPERATIONAL_COST_REJECTION_REASON_LIST untuk memvalidasi reason_type[23]. Tambahkan logika: jika reason_type masuk kategori finansial, pastikan field terkait (competitor_amount atau customer_budget) tidak null.
•	Penanganan Error Terstruktur: Modifikasi RPC rpc_reject_operational_cost_with_reason supaya mengembalikan objek JSON { success: false, error_code: ..., error: ... } alih-alih hanya teks. Di API route, baca error_code ini dan terjemahkan menjadi HTTP 409 untuk status conflict (INVALID_STATUS_TRANSITION atau CONFLICT_*), 404 jika not found, 400 untuk lainnya[24]. Sertakan field_errors bila validasi gagal (422)[25].
•	Status HTTP Benar: Pastikan di route mengembalikan status 422 untuk validasi, 401/403 untuk otorisasi, 404 untuk tidak ditemukan, 409 untuk konflik. Seperti contoh di code terbaru[26][27].
•	Update Data Schema: Migration baru 080_fix_operational_cost_reject_rpc.sql harus: menambahkan kolom created_by/created_at di operational_cost_rejection_reasons (sudah ada), menerima p_actor_user_id/p_correlation_id, melakukan lock SELECT FOR UPDATE di baris ticket_rate_quotes, memperbarui status dan catatan event ke ticket_events dengan p_actor_user_id dan p_correlation_id[22].
•	Frontend/UI: Pastikan form penolakan biaya operasional mengirim semua field (reason_type, competitor_amount dsb.) dan menampilkan pesan field_errors dari respons. Tambahkan correlation_id di log jika ingin debug.
•	Refactor Endpoint Kuotasi/Rejection Reasons: Terapkan konsep serupa di endpoint reject quotation. Gunakan QUOTE_STATUS konstanta dan daftar SSOT untuk reason (API route dan RPC). Validasi tipe alasan, terima param actor_user_id/correlation_id, serta kembalikan error struktural. Periksa fungsi rpc_reject_quotation_with_reason di migrations, tambahkan p_actor_user_id jika perlu.
•	Perbaikan Enum Status: Jika logika bisnis tidak lagi membutuhkan status waiting_vendor/on_hold, hapus rujukan ini di kode front/back agar konsisten dengan enum DB[3]. Jika memang diperlukan, tambahkan nilai baru pada definisi enum Postgres (alter type) dengan hati-hati dan update dokumen; namun lebih baik menggunakan status yang sudah ada. Sebagai solusi cepat, hindari menggunakan status yang tidak ada di DB.
•	“Assign to Sales” (Lead Handover) Enhancement:
•	UI Dialog: Tambahkan dialog/komponen di frontend saat user memilih Assign to Sales. Form harus menyertakan input potential_revenue (di samping notes dan priority) sesuai RPC rpc_lead_handover_to_sales_pool[5]. Tandai kolom ini wajib dan validasi >0.
•	Backend API: Endpoint (mis. /api/crm/leads/[id]/handover) harus memanggil RPC rpc_lead_handover_to_sales_pool dengan parameter p_potential_revenue. Pastikan mengirim idempotency_key untuk mencegah duplikasi jika user klik ganda.
•	DB Schema: Tabel lead_handover_pool (jika ada) akan menyimpan entry baru berisi potential_revenue dari RPC. Namun, schema saat ini belum menampilkan kolom potential_revenue di lead_handover_pool[28] – periksa dan tambahkan kolom ini jika memang dibutuhkan. (Atau cukup disimpan di tabel leads.latest_quotation_id.)
•	Audit dan Status Terminal: Setelah Handover sukses, ubah status Lead menjadi terminal (“Assign to Sales”) dan buat activity log di tabel activities (atau ticket_events) agar tercatat tindakan ini. Pastikan activities menyimpan lead_id, action="assign_to_sales", created_by, timestamp[29].
•	Trigger Pipeline Stage Changes:
•	Buat Fungsi log_stage_change(): Definisikan PL/pgSQL trigger function yang membaca nilai OLD.stage dan NEW.stage pada tabel opportunities dan memasukkan satu baris ke pipeline_updates (kolom opportunity_id, old_stage, new_stage, updated_by diisi dengan auth.uid() atau NEW.owner_user_id, dan updated_at). Sertakan juga notes/evidence jika diperlukan.
•	Pasang Trigger: Pastikan trigger AFTER UPDATE ON opportunities FOR EACH ROW menjalankan fungsi log_stage_change() (telah terdaftar di schema[8]). Jika belum ada, tambahkan CREATE TRIGGER ... EXECUTE FUNCTION log_stage_change().
•	Data Pipeline di Frontend: Setelah stage berubah (di UI Pipeline Board), panggil API yang melakukan UPDATE pada opportunities.stage agar trigger aktif. Verifikasi entri pipeline_updates muncul.
•	Sinkronisasi ke Activities: Selain tabel pipeline_updates, buat juga entri di tabel activities untuk setiap perubahan stage (kolom enrollment_id dapat diabaikan, cukup isi owner_user_id, notes="Stage changed to X", dsb.). Ini memastikan audit log lengkap dan sesuai keperluan tracking.
•	Perbaikan SLA & Ticket Tracking:
•	Buat Baris SLA Tracking Saat Ticket Dibuat: Tambahkan trigger AFTER INSERT ON tickets untuk menjalankan fungsi yang menambahkan row di ticket_sla_tracking dengan ticket_id=NEW.id. Set kolom waktu first_response_at dan resolution_at null sementara, first_response_hours diisi dari config (join ticketing_sla_config berdasarkan department dan ticket_type), serta resolution_hours. Ini menginisialisasi tracking SLA.
•	Update SLA Saat Ada Komentar Pertama: Saat trigger auto_record_response_on_comment() mencatat respons pertama (role ‘creator’ vs ‘assignee’), modifikasi fungsi tersebut untuk juga mengupdate ticket_sla_tracking.first_response_at = NEW.created_at. Hitung selisih ke ticketing_sla_config.first_response_hours dengan calculate_business_hours_seconds(), isi first_response_sla_hours dan first_response_met = (<=target).
•	Update SLA Saat Ticket Resolved: Buat trigger BEFORE UPDATE ON tickets yang memeriksa perubahan status ke closed/solved. Pada penyelesaian, isi ticket_sla_tracking.resolution_at = now(), hitung resolution_sla_hours dan resolution_met. (Fungsi calculate_business_hours_seconds dan tabel sla_holidays sudah ada[30].)
•	Tracking Tiket dan Komentar: Pastikan trigger di ticket_comments (auto_record_response_on_comment) berfungsi[19], sehingga setiap komentar menjadi satu record di ticket_responses. Tabel ticket_responses sudah didefinisikan dengan foreign key ke ticket_comments dan tickets[10]; jika tidak aktif, periksa policy RLS Supabase apakah menghalangi trigger ini.
•	Sinkronisasi ke Activities: Setiap respons atau perubahan status tiket juga bisa dicatat di activities (tabel ini mendukung referensi ke tiket via opportunity_id/lead_id). Tambahkan entri ke activities (tipe “ticket_response” atau “status_change”) untuk integrasi penuh dengan audit kegiatan.
•	Penggunaan SSOT (Constanta) di Seluruh Kode: Lakukan refactor di kode front/backend agar konsisten menggunakan konstanta yang didefinisikan di src/lib/constants (mis. TICKET_STATUS, QUOTE_STATUS, OPERATIONAL_COST_REJECTION_REASON_LIST) alih-alih string literal. Ini mencegah mismatches antara kode dan DB[2]. Contoh: jika enum Postgres ditambahkan/nama diubah, cukup perbarui di satu tempat (constants), bukan di banyak bagian kode.
•	Pergantian Status Kode HTTP & Error Handling: Verifikasi setiap endpoint API:
•	Kembalikan 409 Conflict untuk transisi status yang tidak valid (INVALID_STATUS_TRANSITION), seperti contoh di route reject OPR[31].
•	Kembalikan 422 Unprocessable Entity untuk kesalahan input/validasi (mis. reason kosong atau numeric field tidak ada)[25].
•	Sertakan selalu error_code dan correlation_id di body JSON respons (middleware telah menambahkan correlation_id untuk tiap request[2]).
•	Pastikan frontend membaca field_errors untuk menampilkan pesan form validasi.
•	Perubahan Frontend Lainnya:
•	Untuk aksi-aksi lain seperti adjustment requests atau ticket actions, periksa apakah correlation_id sudah diteruskan di log (sesuai fix-pack, semua endpoint ticketing harus menghasilkannya[32]).
•	Konsistenkan UI: misalnya jika suatu enum tidak digunakan, jangan tampilkan di dropdown. Pastikan PATCH status tidak tersedia di frontend jika sudah dilarang (misalnya dalam komponen detail kuotasi seharusnya tidak ada tombol PATCH setelah final).
Superprompt Claude per Bug
1.	Operasional Cost Reject:
Superprompt: “Patch kode Next.js di api/ticketing/operational-costs/[id]/reject/route.ts: gantikan literal status ‘sent’ dengan QUOTE_STATUS.SENT, tambahkan p_actor_user_id dan p_correlation_id saat memanggil RPC. Perbaiki handling error sehingga mengembalikan error_code dan field_errors sesuai standard. Di Supabase, buat migration SQL (080_fix_operational_cost_reject_rpc.sql) yang mengubah fungsi rpc_reject_operational_cost_with_reason menerima dua parameter baru (actor ID dan correlation ID), melakukan SELECT FOR UPDATE, serta mengisi tabel ticket_events dengan kolom created_by dan correlation_id. Uji dengan unit test: permintaan reject pada status selain SENT harus berespon 409 dengan INVALID_STATUS_TRANSITION[1][2].”
2.	Hardcoded Reason Types:
Superprompt: “Refactor semua endpoint penolakan (operational cost, quotation) agar menggunakan daftar SSOT konstanta (mis. OPERATIONAL_COST_REJECTION_REASON_LIST, QUOTATION_REJECTION_REASON_LIST). Ganti literal string dalam kode dengan konstanta ini. Di setiap route, tambahkan validasi: jika reason_type bukan dalam list, kembalikan error 422 dengan kode VALIDATION_ERROR. Sesuaikan dokumentasi frontend agar pilihan alasan sinkron dengan konstanta di code. Contoh periksa OPERATIONAL_COST_REJECTION_REASON_LIST di route[33].”
3.	Enum Status Mismatch:
Superprompt: “Audit referensi status ‘waiting_vendor’ dan ‘on_hold’ di seluruh kode (backend dan frontend). Jika ditemukan, ganti atau hapus sesuai fitur. Misalnya, jika kode memeriksa ticket.status == 'on_hold', ubah status ke nilai enum yang valid (lihat ticket_status di schema[34]). Jika fitur membutuhkan status ini, gunakan migration untuk alter enum (butuh downtime, risk tinggi) atau tambahkan mapping ke status terdekat. Perbarui dokumen alur sesuai enum yang berlaku.”
4.	Assign to Sales (Potential Revenue):
Superprompt: “Implementasikan dialog input potential_revenue di UI saat aksi Assign to Sales. Perbarui komponen form di src/components/crm/leads/LeadDetail agar memunculkan field numeric untuk potential_revenue. Kemudian di API route (mis. /api/crm/leads/[id]/handover), tambahkan p_potential_revenue dari input ini saat memanggil RPC rpc_lead_handover_to_sales_pool[5]. Pastikan field ini wajib (Validasi_ERROR jika null). Verifikasi bahwa setelah panggilan sukses, lead berpindah ke Sales Inbox (status terminal) dan entri di activities bertulis “Assigned to Sales – potential revenue = X”.”
5.	Pipeline Stage Update:
Superprompt: “Buat fungsi trigger log_stage_change() di Supabase: pada opportunities AFTER UPDATE, baca OLD.stage dan NEW.stage. Masukkan baris baru ke pipeline_updates (tabel schema[6]) dengan opportunity_id = NEW.opportunity_id, old_stage = OLD.stage, new_stage = NEW.stage, updated_at = now(), updated_by = auth.uid() atau NEW.owner_user_id. Kemudian buat trigger AFTER UPDATE ON opportunities FOR EACH ROW EXECUTE FUNCTION log_stage_change(). Uji dengan mengubah stage Opportunity via API – cek tabel pipeline_updates dan juga apakah tabel activities memiliki log perubahan tersebut.”
6.	Ticketing & SLA:
Superprompt: “Tambahkan automasi pencatatan SLA: buat trigger AFTER INSERT ON tickets yang membuat row di ticket_sla_tracking (dengan target jam dari ticketing_sla_config). Tambahkan di fungsi auto_record_response_on_comment() (atau trigger komentar) update untuk first_response_at. Tambahkan trigger BEFORE UPDATE ON tickets untuk status selesai, yang mengisi resolution_at. Periksa tabel ticket_responses definisi[10] agar FOREIGN KEY komentar tegas. Uji skenario: buat tiket baru, berikan komentar pertamanya -> cek ticket_sla_tracking.first_response_at terisi dan ticket_responses bertambah; tutup tiket -> cek resolution_at tercatat.”
7.	Unused Entities Removal:
Superprompt: “Identifikasi entitas tanpa referensi aktif: cadences, cadence_steps, cadence_enrollments, dan relasi terkait. Jika tidak digunakan di API/Frontend, lakukan DROP TABLE secara hati-hati. Contoh SQL:

 	DROP TABLE IF EXISTS public.cadence_steps CASCADE;
DROP TABLE IF EXISTS public.cadences CASCADE;
DROP TABLE IF EXISTS public.cadence_enrollments CASCADE;
 	Juga drop function generate_sales_plan_id dan tabel sales_plans jika benar-benar tidak terpakai. Sebelum drop, lakukan query SELECT 1 FROM ... LIMIT 1 untuk memastikan row kosong. Karena trigger ID generator (lihat [20]) terpasang, hapus trigger tersebut terlebih dahulu.”
Penghapusan Otomatis Entitas Tidak Digunakan
•	Cadence & Nurture: Tabel-tabel cadences (cadences, cadence_steps, cadence_enrollments) tidak digunakan di API/Front. Pastikan tidak ada kode memanggilnya, lalu aman dihapus. SQL contoh:

 	DROP TABLE IF EXISTS public.cadence_steps CASCADE;
DROP TABLE IF EXISTS public.cadences CASCADE;
DROP TABLE IF EXISTS public.cadence_enrollments CASCADE;
 	Ini akan menghapus juga trigger/function terkait (CASCADE) karena tidak ada depensi aktif lainnya.
•	Sales Plans: Jika fitur sales plan belum diimplementasi di UI, tabel sales_plans beserta trigger generate_sales_plan_id dapat dihapus. SQL:

 	DROP TABLE IF EXISTS public.sales_plans CASCADE;
 	Namun periksa dulu penggunaan via grep di kode sumber.
•	Enum dan Views: Tidak ada views tambahan. Jika ada enum Postgres yang tak terpakai, misalnya user_role sudah lazim, sebaiknya biarkan kecuali diketahui pasti tidak lagi dipakai. (Menghapus enum secara manual rumit, biasanya tidak perlu kecuali benar-benar tidak lagi digunakan).
Quality Gate Checklist
Sebelum Fix:
- [ ] Verifikasi baseline: jalankan test E2E dari dokumen QA (lihat docs/qa-e2e-scenarios). Pastikan bug ter-reproduce.
- [ ] Cek konektivitas API-DB: pastikan migration Supabase terakhir dijalankan (080_fix_… dll).
- [ ] Back up database/schema saat ini.
Setelah Fix:
- [ ] Semua unit/integrasi test ticketing, quotation, pipeline, dan lead terlewati tanpa error.
- [ ] Endpoint /api/ticketing/operational-costs/[id]/reject berespon 409 dengan INVALID_STATUS_TRANSITION jika status salah, 422 jika alasan tidak valid[2][25].
- [ ] Setiap transaksi penolakan (cost/quotation) membuat entry di ticket_events dengan actor_user_id dan correlation_id.
- [ ] Lead yang di-Assign to Sales tercatat nilai potential_revenue dan berpindah status terminal; user tidak bisa ubah status setelahnya (bawaan terminal).
- [ ] Tabel pipeline_updates terisi setiap kali opportunities.stage berubah, dengan kolom old_stage/new_stage cocok perubahan. Activities log juga mencatat perubahan ini.
- [ ] Tabel ticket_responses bertambah ketika ada komentar, dan ticket_sla_tracking tercipta saat tiket baru & terupdate saat first_response/resolution.
- [ ] Tidak ada error baru di console log frontend/backend. Semua correlation_id tampil konsisten di log/error.
- [ ] Cek data integrity: pastikan foreign key (contoh opportunities.source_lead_id) tetap valid dan tidak ada kecocokan terputus akibat perubahan enum atau drop table.
- [ ] Lakukan verifikasi manual: coba skenario di QA Playbook (khususnya terkait biaya operasional, kuotasi, pipeline, dan SLA). Semua jalur harus sesuai ekspektasi tanpa exception.
Dengan langkah-langkah ini, setiap bug tuntas diperbaiki, skema data Supabase diperbarui sesuai, dan verifikasi menyeluruh memastikan seluruh logika berintegrasi dengan baik[1][6]. Semua perubahan saling sinkron tanpa memicu bug baru.
________________________________________
[1] [3] [12] [13] [22] [32] fix-pack-pr6-pr8.md
https://github.com/assujiar/ugc-business-command-portal/blob/068acffb4f85e62204f8c63ebc9ffa3879f4a171/docs/fix-pack-pr6-pr8.md
[2] [21] [23] [24] [25] [26] [27] [31] [33] route.ts
https://github.com/assujiar/ugc-business-command-portal/blob/068acffb4f85e62204f8c63ebc9ffa3879f4a171/src/app/api/ticketing/operational-costs/[id]/reject/route.ts
[4] [5] [6] [7] [8] [9] [10] [11] [14] [15] [16] [18] [19] [20] [28] [30] [34] data_scheme.md
file://file_000000004cdc72088439f44e053bc014
[17] [29] QA_PLAYBOOK.md
https://github.com/assujiar/ugc-business-command-portal/blob/068acffb4f85e62204f8c63ebc9ffa3879f4a171/docs/QA_PLAYBOOK.md
